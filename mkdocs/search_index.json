{
    "docs": [
        {
            "location": "/", 
            "text": "DMS NZ - PyQGIS Workshop Plugin\n\n\nCourse outline:\n\n\n\n\nGetting Started\n\n\nDeploying Plugin\n\n\nCreating the UI and adding logic\n\n\nAdding QGIS logic\n\n\n\n\nExtra Bits:\n\n\n\n\nOther places Python can be used in QGIS", 
            "title": "Home"
        }, 
        {
            "location": "/#dms-nz-pyqgis-workshop-plugin", 
            "text": "Course outline:   Getting Started  Deploying Plugin  Creating the UI and adding logic  Adding QGIS logic   Extra Bits:   Other places Python can be used in QGIS", 
            "title": "DMS NZ - PyQGIS Workshop Plugin"
        }, 
        {
            "location": "/started/", 
            "text": "Getting Started - Creating the base plugin\n\n\nGoals\n\n\n\n\nGenerate a plugin using the QGIS plugin builder\n\n\nView plugin layout\n\n\nView plugin metadata\n\n\nView main plugin code\n\n\n\n\nHandy Links\n\n\nHere are some links that we might use throughout the workshop or you can use later when building a plugin or working with the QGIS Python API.\n\n\n\n\nQGIS API: http://qgis.org/api/\n\n\n2.8 http://qgis.org/api/2.8/\n\n\nQGIS cookbook: http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/\n\n\n\n\nNote:\n We will be using 2.8 as the target install for PyQGIS. However as the API is stable between 2.x version, using 2.10 is also fine.\n\n\nPlugin goals\n\n\nThe goal of the workshop is to create a plugin but not just a \u201chere is how to open a layer\u201d type plugin, although they are handy,\n they don\u2019t get you very far and the cookbook already covers that.\nLet's build something that touches on different parts of the application, from symbols, layers, features, and even drag and drop if we get time.\n\n\nThe final goal of the plugin is to create something that can update QGIS features based on a pre-defined templates.\n\n\nHere is an example of the UI that we are going to build:\n\n\n\n\nCreating the plugin\n\n\nWe are not going to start from nothing, that doesn\u2019t really help us, so we are going to use the QGIS plugin builder\nto get up and running. \n\n\nThis is only so we can get something started. A more correct plugin, something that you can publish for others to \nuse, can need more work and polish.\n\n\nQGIS Plugin builder\n\n\nFor this we will need the QGIS plugin builder. This is a plugin you can install in QGIS that will\ngenerate a plugin for you that is ready to go.\n\n\n\n\nOpen QGIS and install the QGIS Plugin Builder Plugin\n\n\nFrom \nPlugins -\n Plugin Builder\n run the plugin\n\n\n\n\nThe plugin builder will gives us a screen to fill in all the information that is needed.  Go ahead and complete the \ninformation as shown below:\n\n\n\n\n\n\nBe sure to select \nTool button with dock widget\n as the template\n\n\n\n\nOne should always add unit tests to our code but we won't here because it's just an example :P \n\n\nWe are also using \npb_tool\n so untick \nMakefile\n\n\n\n\nIf you want to publish the plugin for others it needs to have a bug tracker and code repository. However we can put in stub\nentries for those now, as we don't need it yet and it's only enforced at publish time.\n\n\n\n\nThe next screen will ask you to select a folder to save the plugin into.  Save it into a known place for you. It doesn't matter\nwhere just somewhere easy to get to.\n\n\nPyCharm project\n\n\nWe need to create a PyCharm project from the folder that was generated by the plugin builder.\n\n\n\n\nOpen PyCharm and select \nFile -\n Open\n and select the folder that you just created using the plugin.  \n\n\n\n\n\n\n\n\nOpen \nFile -\n Settings\n\n\nSearch for \nProject\n \n\n\nSet the \nProject Interpreter\n to the QGIS installed one.\n\n\n\n\n\n\nNote\n: On Linux/OS X this is the default Python install. No need to do anything here.\n\n\nPlugin layout break down\n\n\nBefore we get started it\u2019s best to explain the basic layout of the simple plugin we have here\n\n\n\n\n__init__.py\n - The main entry point for this plugin that is called when QGIS loads the plugin\n\n\nLICENSE\n - Well I\u2019m sure you can guess\n\n\nmetadata.txt\n - The plugin metadata that is used when uploading the plugin to the plugin repository and when QGIS loads the plugin\n\n\nfeature_template.py\n - The main code file for this plugin.  We will be adding a few more of these throughout the workshop\n\n\nREADME.txt\n - The README for the plugin\n\n\npb_tool.cfg\n - The \npb_tool\n config file. Used to build and deploy the plugin\n\n\nresoruces.qrc\n - Qt resource file used to add icons to buttons and widgets.\n\n\nfeature_template_dockwidget_base.ui\n - The base dock widget UI base file. We will open this in Qt Designer a bit later\n\n\nfeature_template_dockwidget.py\n - Core logic for the \nfeature_template_dockwidget_base.ui\n\n\n\n\nThere is also a scripts folder and help folder which we won't go into at this stage.\n\n\nMetadata\n\n\nOpen the metadata.txt file in PyCharm and have a look at the layout. This file contains all the information that used\nby QGIS when it displays the plugin in the installer.\n\n\n__init__\n file and plugin entry point\n\n\nOpen up the \n__init__\n file.  This file marks this folder as a Python package and QGIS can load a Python package\nas a plugin if the package setup is right.\n\n\nInside \n__init__\n you will find\n\n\ndef classFactory(iface):\n    \nLoad FeatureTemplates class from file FeatureTemplates.\n\n    :param iface: A QGIS interface instance.\n    :type iface: QgsInterface\n    \n\n    #\n    from .feature_template import FeatureTemplates\n    return FeatureTemplates(iface)\n\n\n\n\nThe \nclassFactory\n method is called when QGIS loads the plugin. QGIS will pass the API interface object (\nQgisInterface\n)\ninto your plugin. This object is normally used to talk to the main QGIS UI interface.\n\n\nThe main thing this function does is return an instance of the class for your plugin (\nFeatureTemplates\n).  \nFeatureTemplates\n can be\nfound in \nfeature_template.py\n\n\nPluginCore\n\n\nLet's take a quick look at \nfeature_template.py\n before we do a test plugin install.  There is a lot of stuff in this\ntemplate but we just need to have a quick look at a few methods\n\n\nThe two main important methods here are \ninitGui\n and \nunload\n. \n\n\n\n\ninitGui\n is called when the plugin is loaded from QGIS.  Called when QGIS is loaded. We normally setup events, buttons, etc here\n\n\nunload\n is called when the plugin is uploaded from the interface.  We do things that remove the plugin from the QGIS interface.\n\n\n\n\nImportant!\n\n\nDon't skip this step as the plugin will not load correctly\n\n\nBefore we move on we need to update one thing the plugin builder doesn't generate correctly.  \n\n\nAt the top replace: \nimport resources\n with \nimport resources_rc\n\n\nLets move on to \ndeploying\n the project to test this.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/started/#getting-started-creating-the-base-plugin", 
            "text": "Goals   Generate a plugin using the QGIS plugin builder  View plugin layout  View plugin metadata  View main plugin code   Handy Links  Here are some links that we might use throughout the workshop or you can use later when building a plugin or working with the QGIS Python API.   QGIS API: http://qgis.org/api/  2.8 http://qgis.org/api/2.8/  QGIS cookbook: http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/   Note:  We will be using 2.8 as the target install for PyQGIS. However as the API is stable between 2.x version, using 2.10 is also fine.", 
            "title": "Getting Started - Creating the base plugin"
        }, 
        {
            "location": "/started/#plugin-goals", 
            "text": "The goal of the workshop is to create a plugin but not just a \u201chere is how to open a layer\u201d type plugin, although they are handy,\n they don\u2019t get you very far and the cookbook already covers that.\nLet's build something that touches on different parts of the application, from symbols, layers, features, and even drag and drop if we get time.  The final goal of the plugin is to create something that can update QGIS features based on a pre-defined templates.  Here is an example of the UI that we are going to build:", 
            "title": "Plugin goals"
        }, 
        {
            "location": "/started/#creating-the-plugin", 
            "text": "We are not going to start from nothing, that doesn\u2019t really help us, so we are going to use the QGIS plugin builder\nto get up and running.   This is only so we can get something started. A more correct plugin, something that you can publish for others to \nuse, can need more work and polish.  QGIS Plugin builder  For this we will need the QGIS plugin builder. This is a plugin you can install in QGIS that will\ngenerate a plugin for you that is ready to go.   Open QGIS and install the QGIS Plugin Builder Plugin  From  Plugins -  Plugin Builder  run the plugin   The plugin builder will gives us a screen to fill in all the information that is needed.  Go ahead and complete the \ninformation as shown below:    Be sure to select  Tool button with dock widget  as the template   One should always add unit tests to our code but we won't here because it's just an example :P   We are also using  pb_tool  so untick  Makefile   If you want to publish the plugin for others it needs to have a bug tracker and code repository. However we can put in stub\nentries for those now, as we don't need it yet and it's only enforced at publish time.   The next screen will ask you to select a folder to save the plugin into.  Save it into a known place for you. It doesn't matter\nwhere just somewhere easy to get to.  PyCharm project  We need to create a PyCharm project from the folder that was generated by the plugin builder.   Open PyCharm and select  File -  Open  and select the folder that you just created using the plugin.       Open  File -  Settings  Search for  Project    Set the  Project Interpreter  to the QGIS installed one.    Note : On Linux/OS X this is the default Python install. No need to do anything here.", 
            "title": "Creating the plugin"
        }, 
        {
            "location": "/started/#plugin-layout-break-down", 
            "text": "Before we get started it\u2019s best to explain the basic layout of the simple plugin we have here   __init__.py  - The main entry point for this plugin that is called when QGIS loads the plugin  LICENSE  - Well I\u2019m sure you can guess  metadata.txt  - The plugin metadata that is used when uploading the plugin to the plugin repository and when QGIS loads the plugin  feature_template.py  - The main code file for this plugin.  We will be adding a few more of these throughout the workshop  README.txt  - The README for the plugin  pb_tool.cfg  - The  pb_tool  config file. Used to build and deploy the plugin  resoruces.qrc  - Qt resource file used to add icons to buttons and widgets.  feature_template_dockwidget_base.ui  - The base dock widget UI base file. We will open this in Qt Designer a bit later  feature_template_dockwidget.py  - Core logic for the  feature_template_dockwidget_base.ui   There is also a scripts folder and help folder which we won't go into at this stage.", 
            "title": "Plugin layout break down"
        }, 
        {
            "location": "/started/#metadata", 
            "text": "Open the metadata.txt file in PyCharm and have a look at the layout. This file contains all the information that used\nby QGIS when it displays the plugin in the installer.", 
            "title": "Metadata"
        }, 
        {
            "location": "/started/#__init__-file-and-plugin-entry-point", 
            "text": "Open up the  __init__  file.  This file marks this folder as a Python package and QGIS can load a Python package\nas a plugin if the package setup is right.  Inside  __init__  you will find  def classFactory(iface):\n     Load FeatureTemplates class from file FeatureTemplates.\n\n    :param iface: A QGIS interface instance.\n    :type iface: QgsInterface\n     \n    #\n    from .feature_template import FeatureTemplates\n    return FeatureTemplates(iface)  The  classFactory  method is called when QGIS loads the plugin. QGIS will pass the API interface object ( QgisInterface )\ninto your plugin. This object is normally used to talk to the main QGIS UI interface.  The main thing this function does is return an instance of the class for your plugin ( FeatureTemplates ).   FeatureTemplates  can be\nfound in  feature_template.py", 
            "title": "__init__ file and plugin entry point"
        }, 
        {
            "location": "/started/#plugincore", 
            "text": "Let's take a quick look at  feature_template.py  before we do a test plugin install.  There is a lot of stuff in this\ntemplate but we just need to have a quick look at a few methods  The two main important methods here are  initGui  and  unload .    initGui  is called when the plugin is loaded from QGIS.  Called when QGIS is loaded. We normally setup events, buttons, etc here  unload  is called when the plugin is uploaded from the interface.  We do things that remove the plugin from the QGIS interface.", 
            "title": "PluginCore"
        }, 
        {
            "location": "/started/#important", 
            "text": "Don't skip this step as the plugin will not load correctly  Before we move on we need to update one thing the plugin builder doesn't generate correctly.    At the top replace:  import resources  with  import resources_rc", 
            "title": "Important!"
        }, 
        {
            "location": "/started/#lets-move-on-to-deploying-the-project-to-test-this", 
            "text": "", 
            "title": "Lets move on to deploying the project to test this."
        }, 
        {
            "location": "/deploy/", 
            "text": "Installing the plugin\n\n\nA plugin is no good if it's not installed anywhere.  Plugins are installed in the \nqgis2\\python\\plugins\n folder but normally\nit's a good idea to develop outside of that folder (this is your decision of course) and just deploy what is require into there.\n\n\nYou can copy the files in there manually however we have a tool (\npb_tool\n) that can do it for us.\n\n\n\n\nRun \nOSGeo4W.bat\n from the QGIS install folder\n\n\ncd FeatureTemplates\n\n\npb_tool deploy\n\n\n\n\nDeploying will:\n                * Remove your currently deployed version\n                * Compile the ui and resource files\n                * Build the help docs\n                * Copy everything to your .qgis2/python/plugins directory\n\nProceed? [y/N]: \n\n\n\n\nHit \ny\n and it will build and deploy the plugin.\n\n\nLeave this console open because we are going to come back to it\n\n\nThis will create a publish metadata file and deploy it to \nqgis2\\python\\plugins\n. Open Windows Explorer to view the\n installed plugin. \n\n\n\n\nYou will also notice that once deployed you don't have as many files.  Only the files that are needed at pushed the plugin\nfolder.\n\n\n\n\nFire up QGIS and you should be able to see the plugin in the plugin manager and installer.\n\n\n\n\nEnable the plugin and select the new entry in the plugins menu.\n\n\n\n\n\n\nIf everything worked as expected we now have the plugin loaded and showing the empty dock panel on the right hand\nside \n\n\nPRO TIP!\n\n\nInstall the \nPlugin Reloader\n plugin in order to reload plugins without reloading QGIS.\n\n\nNow let's do something \ncool", 
            "title": "Deploying Plugin"
        }, 
        {
            "location": "/deploy/#installing-the-plugin", 
            "text": "A plugin is no good if it's not installed anywhere.  Plugins are installed in the  qgis2\\python\\plugins  folder but normally\nit's a good idea to develop outside of that folder (this is your decision of course) and just deploy what is require into there.  You can copy the files in there manually however we have a tool ( pb_tool ) that can do it for us.   Run  OSGeo4W.bat  from the QGIS install folder  cd FeatureTemplates  pb_tool deploy   Deploying will:\n                * Remove your currently deployed version\n                * Compile the ui and resource files\n                * Build the help docs\n                * Copy everything to your .qgis2/python/plugins directory\n\nProceed? [y/N]:   Hit  y  and it will build and deploy the plugin.  Leave this console open because we are going to come back to it  This will create a publish metadata file and deploy it to  qgis2\\python\\plugins . Open Windows Explorer to view the\n installed plugin.    You will also notice that once deployed you don't have as many files.  Only the files that are needed at pushed the plugin\nfolder.   Fire up QGIS and you should be able to see the plugin in the plugin manager and installer.   Enable the plugin and select the new entry in the plugins menu.    If everything worked as expected we now have the plugin loaded and showing the empty dock panel on the right hand\nside   PRO TIP!  Install the  Plugin Reloader  plugin in order to reload plugins without reloading QGIS.", 
            "title": "Installing the plugin"
        }, 
        {
            "location": "/deploy/#now-lets-do-something-cool", 
            "text": "", 
            "title": "Now let's do something cool"
        }, 
        {
            "location": "/addingui/", 
            "text": "Creating the UI and first logic\n\n\nTo create the UI you will need Qt Designer. This is shipped with QGIS and installed in the \nbin\n folder of the install.\n\n\nRun the application called \ndesigner.exe\n\n\nAfter we open designer we are going to select \nOpen..\n and select \nfeature_template_dockwidget_base.ui\n\n\n\n\nSelect and delete the label that is already in the dock widget.\n\n\nWidgets\n\n\n\n\nProperties\n\n\n\n\nFor our widget we are going to need a \nStacked Widget\n.\n\n\n\n\nDrag the stack widget onto the form\n\n\nRight click in the empty form and select \nLayout -\n Layout in Grid\n\n\n\n\nAll Qt widgets are contained in layouts.  The layout controls how the widgets fit together.\n\n\nWe can use the stacked widget to add move \"pages\" to our widget later if we connect the define new button.\n\n\nYou will also need 3x \nPush Button\n and a \nList Widget\n.  \n\n\nDrag the buttons and list widget inside the stacked widget\n\n\n\n\nDon't worry if they don't look right. When we set the layout it will fix them up for us\n\n\n\n\n\n\nSelect a button and hit F2 to label the buttons. We need \nDefine new\n, \nDelete\n, \nApply\n\n\nAlso update the object name on the buttons and list widget (\ntemplatesList\n, \nnewButton\n, \ndeleteButton\n, \napplyButton\n)\n\n\nDrag the widget around the form to change the layout\n\n\n\n\nThe name of the object is important because we will use this in the code to set more things.\n\n\n\n\nSave the UI file into your plugin working folder. Call it \nui_templatedock.ui\n\n\n\n\nGenerating the UI files\n\n\nQt has a handy function for creating the UI files on the fly.  This removes the build step for generating the UI files\n\n\nQt only needs the path to the \n.ui\n file and it will generate the Python object on the fly ready to use.\n\n\nOpen \nfeature_template_dockwidget.py\n\n\nFORM_CLASS, _ = uic.loadUiType(os.path.join(\n    os.path.dirname(__file__), 'feature_template_dockwidget_base.ui'))\n\n\n\n\nuic.loadUiType\n will load the UI on the fly from the \n.ui\n file without the need for the compile step.\n\n\nAdding some items to the list\n\n\nBefore we start on doing anything in QGIS itself.  Let's just add a few items to the list.  \n\n\nIt's going to be a hard-coded list for now but we can add config for it later.\n\n\nDefine it like this in the \nfeature_template_dockwidget.py\n file\n\n\nitems = {\n    \nwater pipe - 100mm\n:\n        {\n            \ntype\n: \nwater pipe\n,\n            \nsize\n: 100\n        },\n    \nsewer pipe - 200mm\n:\n        {\n            \ntype\n: \nsewer pipe\n,\n            \nsize\n: 200\n        }\n}\n\n\n\n\nIn the \nFeatureTemplatesDockWidget\n class we need to add new method to load the items\n\n\n    def load_items(self):\n        self.templatesList.clear()\n        for key in items:\n            self.templatesList.addItem(key)\n\n\n\n\n\nin the \nrun\n method of \nfeature_template.py\n. Make sure you call \nload_items\n\n\n    def run(self):\n        ... \n        self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)\n        self.dockwidget.show()\n        self.dockwidget.load_items()\n\n\n\n\nSignals and Slots\n\n\nQt, and QGIS, uses Signals and Slots to message objects about events that have happened.  They are a great thing to use\nwhen parts of your applications need to talk to each other.\n\n\nHere is a quick run down.\n\n\n\n\nObjects can define signals which are emitted.\n\n\nObject can connect slots to these signals to handle the event\n\n\nNormal Python functions can be used for slots without any extra work\n\n\n\n\nHere is an example:\n\n\ndef do_event(self):\n    print \nDo something\n\n\nmybuttton.pressed.connect(self.do_event)\n\n\n\n\nConnect the Update/Apply button\n\n\nWith that we are going to connect the \nApply/Update\n button in our \nFeatureTemplateDockWidget\n object to \nemit a signal to tell something else to handle the apply logic.\n\n\nIn \nFeatureTemplateDockWidget\n we need to define a signal called \ntemplateApplied\n like so\n\n\nclass FeatureTemplatesDockWidget(QtGui.QDockWidget, FORM_CLASS):\n\n    templateApplied = pyqtSignal(str, dict)\n    closingPlugin = pyqtSignal()\n\n\n\n\nThis signal will emit a string and a dictionary.\n\n\nNote\n: Take note on where \ntemplateApplied\n is defined. Outside of any methods at the class level\n\n\nInside the \n__init__\n method we need to connect the \nApply button\n pressed event and handle the extra logic\n\n\n    def __init__(self, parent=None):\n        super(TemplateDock, self).__init__(parent)\n        self.setupUi(self)\n        self.applyButton.pressed.connect(self.apply_template)\n\n    def apply_template(self):\n        # Don't do anything if there is no selection text\n        if not self.templatesList.currentItem():\n            return\n\n        name = self.templatesList.currentItem().text()\n\n        # Get the fields from the items list\n        fields = items[name]\n        self.templateApplied.emit(name, fields)\n\n\n\n\nWe now need to connect to this signal in the \nFeatureTemplates\n class\n\n\n    def initGui(self):\n        self.dock = TemplateDock()\n        self.dock.templateApplied.connect(self.apply_template)\n        ....\n\n    def apply_template(self, name, fields):\n        pass\n\n\n\n\nWe will come back and wire up \napply_template\n soon\n\n\nRun \npb_tool deploy\n again and restart QGIS (or use the plugin reloader) to test the plugin.  You should now see this:\n\n\n\n\nLets move on using the \nQGIS\n API", 
            "title": "Creating the UI and adding logic"
        }, 
        {
            "location": "/addingui/#creating-the-ui-and-first-logic", 
            "text": "To create the UI you will need Qt Designer. This is shipped with QGIS and installed in the  bin  folder of the install.  Run the application called  designer.exe  After we open designer we are going to select  Open..  and select  feature_template_dockwidget_base.ui   Select and delete the label that is already in the dock widget.  Widgets   Properties   For our widget we are going to need a  Stacked Widget .   Drag the stack widget onto the form  Right click in the empty form and select  Layout -  Layout in Grid   All Qt widgets are contained in layouts.  The layout controls how the widgets fit together.  We can use the stacked widget to add move \"pages\" to our widget later if we connect the define new button.  You will also need 3x  Push Button  and a  List Widget .    Drag the buttons and list widget inside the stacked widget   Don't worry if they don't look right. When we set the layout it will fix them up for us    Select a button and hit F2 to label the buttons. We need  Define new ,  Delete ,  Apply  Also update the object name on the buttons and list widget ( templatesList ,  newButton ,  deleteButton ,  applyButton )  Drag the widget around the form to change the layout   The name of the object is important because we will use this in the code to set more things.   Save the UI file into your plugin working folder. Call it  ui_templatedock.ui", 
            "title": "Creating the UI and first logic"
        }, 
        {
            "location": "/addingui/#generating-the-ui-files", 
            "text": "Qt has a handy function for creating the UI files on the fly.  This removes the build step for generating the UI files  Qt only needs the path to the  .ui  file and it will generate the Python object on the fly ready to use.  Open  feature_template_dockwidget.py  FORM_CLASS, _ = uic.loadUiType(os.path.join(\n    os.path.dirname(__file__), 'feature_template_dockwidget_base.ui'))  uic.loadUiType  will load the UI on the fly from the  .ui  file without the need for the compile step.", 
            "title": "Generating the UI files"
        }, 
        {
            "location": "/addingui/#adding-some-items-to-the-list", 
            "text": "Before we start on doing anything in QGIS itself.  Let's just add a few items to the list.    It's going to be a hard-coded list for now but we can add config for it later.  Define it like this in the  feature_template_dockwidget.py  file  items = {\n     water pipe - 100mm :\n        {\n             type :  water pipe ,\n             size : 100\n        },\n     sewer pipe - 200mm :\n        {\n             type :  sewer pipe ,\n             size : 200\n        }\n}  In the  FeatureTemplatesDockWidget  class we need to add new method to load the items      def load_items(self):\n        self.templatesList.clear()\n        for key in items:\n            self.templatesList.addItem(key)  in the  run  method of  feature_template.py . Make sure you call  load_items      def run(self):\n        ... \n        self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)\n        self.dockwidget.show()\n        self.dockwidget.load_items()", 
            "title": "Adding some items to the list"
        }, 
        {
            "location": "/addingui/#signals-and-slots", 
            "text": "Qt, and QGIS, uses Signals and Slots to message objects about events that have happened.  They are a great thing to use\nwhen parts of your applications need to talk to each other.  Here is a quick run down.   Objects can define signals which are emitted.  Object can connect slots to these signals to handle the event  Normal Python functions can be used for slots without any extra work   Here is an example:  def do_event(self):\n    print  Do something \n\nmybuttton.pressed.connect(self.do_event)  Connect the Update/Apply button  With that we are going to connect the  Apply/Update  button in our  FeatureTemplateDockWidget  object to \nemit a signal to tell something else to handle the apply logic.  In  FeatureTemplateDockWidget  we need to define a signal called  templateApplied  like so  class FeatureTemplatesDockWidget(QtGui.QDockWidget, FORM_CLASS):\n\n    templateApplied = pyqtSignal(str, dict)\n    closingPlugin = pyqtSignal()  This signal will emit a string and a dictionary.  Note : Take note on where  templateApplied  is defined. Outside of any methods at the class level  Inside the  __init__  method we need to connect the  Apply button  pressed event and handle the extra logic      def __init__(self, parent=None):\n        super(TemplateDock, self).__init__(parent)\n        self.setupUi(self)\n        self.applyButton.pressed.connect(self.apply_template)\n\n    def apply_template(self):\n        # Don't do anything if there is no selection text\n        if not self.templatesList.currentItem():\n            return\n\n        name = self.templatesList.currentItem().text()\n\n        # Get the fields from the items list\n        fields = items[name]\n        self.templateApplied.emit(name, fields)  We now need to connect to this signal in the  FeatureTemplates  class      def initGui(self):\n        self.dock = TemplateDock()\n        self.dock.templateApplied.connect(self.apply_template)\n        ....\n\n    def apply_template(self, name, fields):\n        pass  We will come back and wire up  apply_template  soon  Run  pb_tool deploy  again and restart QGIS (or use the plugin reloader) to test the plugin.  You should now see this:", 
            "title": "Signals and Slots"
        }, 
        {
            "location": "/addingui/#lets-move-on-using-the-qgis-api", 
            "text": "", 
            "title": "Lets move on using the QGIS API"
        }, 
        {
            "location": "/qgis/", 
            "text": "Using the QGIS API\n\n\nNow it's time to implement some QGIS based logic.\n\n\nGoals:\n\n\n\n\nHandle apply button\n\n\nHandling layer selection\n\n\nUpdate features based on set fields\n\n\nRefresh the map\n\n\n\n\nFirst things first. We need to handle the \napply_template\n button from the last step in our \nFeatureTemplates\n class.\n\nIn here we are going to grab the selected objects and apply the field data we have in our template to the objects.\n\n\nlayer = self.iface.activeLayer()\n\n\n\n\nWe get the selected objects using:\n\n\nfeatures = layer.selectedFeatures()\n\n\n\n\nTip:\n Look at the \nQgsVectorLayer\n API for what else is possible.\n\n\nPutting it all together we have:\n\n\n    def apply_template(self, name, fields):\n        layer = self.iface.activeLayer()\n        features = layer.selectedFeatures()\n        for feature in features:\n            pass\n\n\n\n\nNow we want to apply the value from the \nfields\n dictionary to the feature. Each \nfeature\n will be of type \nQgsFeature\n\n\n    for feature in features:\n        for field, value in fields.itervalues():\n            feature[field] = value\n            layer.updateFeature(feature)\n\n\n\n\nLoop over all the features and each field/value pair we have and update the values on the feature itself. \nWe use \nlayer.updateFeature\n to update the feature itself with the new values. QGIS doesn't update the values in the layer\nuntil we do this.\n\n\nQgsFeature\n objects can use Python index lookup to reference/assign a field and value. \nfeature[0]\n will also work to \nget the value of the first field. \n\n\nFinally we need to update the map\n\n\nself.iface.mapCanvas().refresh()\n\n\n\n\nHere is the complete method:\n\n\n    def apply_template(self, name, fields):\n        layer = self.iface.activeLayer()\n        features = layer.selectedFeatures()\n        for feature in features:\n            for field, value in fields.iteritems():\n                feature[field] = value\n                layer.updateFeature(feature)\n\n        self.iface.mapCanvas().refresh()\n\n\n\n\nRun \npb_deploy\n and reload the plugin in QGIS.\n\n\nLoad the sample project and test\n\n\nLoad the sample \nworkshop.qgs\n qgis project found in the project folder for this workshop.  This project already has\nsome sample data we can work with. \n\n\nThe data in the sample project doesn't have any type or size data assigned.\n\nWe are now going to use the plugin to assign those values. \n\n\n\n\nSelect some features using the select tool\n\n\nEnable editing in the toolbar\n\n\nSelect a item from the list in the dock\n\n\nHit \napply/update\n\n\n\n\nIf everything is working you can see the new data being applied to the features on the fly. Win!\n\n\n\n\nPRO TIP\n\n\nYou can also try things in the QGIS Python Console to get an idea on how things will work and then using them in your\ncode here.", 
            "title": "Adding QGIS logic"
        }, 
        {
            "location": "/qgis/#using-the-qgis-api", 
            "text": "Now it's time to implement some QGIS based logic.  Goals:   Handle apply button  Handling layer selection  Update features based on set fields  Refresh the map   First things first. We need to handle the  apply_template  button from the last step in our  FeatureTemplates  class. \nIn here we are going to grab the selected objects and apply the field data we have in our template to the objects.  layer = self.iface.activeLayer()  We get the selected objects using:  features = layer.selectedFeatures()  Tip:  Look at the  QgsVectorLayer  API for what else is possible.  Putting it all together we have:      def apply_template(self, name, fields):\n        layer = self.iface.activeLayer()\n        features = layer.selectedFeatures()\n        for feature in features:\n            pass  Now we want to apply the value from the  fields  dictionary to the feature. Each  feature  will be of type  QgsFeature      for feature in features:\n        for field, value in fields.itervalues():\n            feature[field] = value\n            layer.updateFeature(feature)  Loop over all the features and each field/value pair we have and update the values on the feature itself. \nWe use  layer.updateFeature  to update the feature itself with the new values. QGIS doesn't update the values in the layer\nuntil we do this.  QgsFeature  objects can use Python index lookup to reference/assign a field and value.  feature[0]  will also work to \nget the value of the first field.   Finally we need to update the map  self.iface.mapCanvas().refresh()  Here is the complete method:      def apply_template(self, name, fields):\n        layer = self.iface.activeLayer()\n        features = layer.selectedFeatures()\n        for feature in features:\n            for field, value in fields.iteritems():\n                feature[field] = value\n                layer.updateFeature(feature)\n\n        self.iface.mapCanvas().refresh()  Run  pb_deploy  and reload the plugin in QGIS.", 
            "title": "Using the QGIS API"
        }, 
        {
            "location": "/qgis/#load-the-sample-project-and-test", 
            "text": "Load the sample  workshop.qgs  qgis project found in the project folder for this workshop.  This project already has\nsome sample data we can work with.   The data in the sample project doesn't have any type or size data assigned. \nWe are now going to use the plugin to assign those values.    Select some features using the select tool  Enable editing in the toolbar  Select a item from the list in the dock  Hit  apply/update   If everything is working you can see the new data being applied to the features on the fly. Win!", 
            "title": "Load the sample project and test"
        }, 
        {
            "location": "/qgis/#pro-tip", 
            "text": "You can also try things in the QGIS Python Console to get an idea on how things will work and then using them in your\ncode here.", 
            "title": "PRO TIP"
        }, 
        {
            "location": "/other/", 
            "text": "Other places Python can be used\n\n\nCreating a plugin isn't the only place you can use Python to expand QGIS.  \n\n\nOther places that QGIS can be used include:\n\n\n\n\nstartup.py\n - A python script that is run on each QGIS load. (Run before any project or plugins load)\n\n\nexpression functions\n - Custom expression functions can be added using Python functions\n\n\nQGIS Server plugins\n - Custom request handlers for QGIS Server that can process the server request\n\n\nProcessing Toolbox Extenstion\n - Add extra providers to the processing toolbox.", 
            "title": "Other Python uses"
        }, 
        {
            "location": "/other/#other-places-python-can-be-used", 
            "text": "Creating a plugin isn't the only place you can use Python to expand QGIS.    Other places that QGIS can be used include:   startup.py  - A python script that is run on each QGIS load. (Run before any project or plugins load)  expression functions  - Custom expression functions can be added using Python functions  QGIS Server plugins  - Custom request handlers for QGIS Server that can process the server request  Processing Toolbox Extenstion  - Add extra providers to the processing toolbox.", 
            "title": "Other places Python can be used"
        }
    ]
}